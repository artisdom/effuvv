#!/usr/bin/env node

const promisify = require("util").promisify;
const readFile =  promisify(require("fs").readFile);

const zip = (l, r) => l.map((_, i) => [l[i], r[i]]);

const getPathOf = (() => {
  const fileExists = promisify(require("fs").exists);

  let configPaths;
  try {
    configPaths = [
      `${ __dirname }/configs/${ await readFile(`${ __dirname }/config_dir`, "utf8") }`,
      `${ __dirname }/configs/default`,
    ];
  } catch (_e) {
    configPaths = [ `${ __dirname }/configs/default` ];
  }

  return async (name) =>
    zip(
      configPaths,
      await Promise.all(configPaths.map(path => fileExists(`${ path }/${ name }`))),
    )
    .filter(([ , exists ]) => exists)
    .map(([ name, ]) => name)
    [0]
  ;
})();

const install = (() => {
  const copy = promisify(require("fs.extra").copy);

  return async (names) => 
    await Promise.all(
      zip(
        await Promise.all(names.map(getPathOf)),
        names
      )
      .map(([ from, to ]) => {
        if (from == null) {
          throw new Error(`missing source file ${ to }`);
        }

        console.log(`Copying file from '${ from }' to '${ to }'`);
        return copy(from, to, {
          overwrite:          true,
          errorOnExist:       false,
          dereference:        false,
          preserveTimestamps: true,
        });
      })
    )
  ;
})();

const run = promisify(require("child_process").exec);



const packages = (() => {
  const degroup = async (names) => 
    (await Promise.all(names.map(name => {
      let groupStr = null;
      try {
        groupStr = await run(`pacman -Qqg ${ name }`);
      } catch (_e) {
        groupStr = false;
      }

      if (groupStr === false) {
        return [ name ];
      } else {
        return groupStr.split("\n").map(s => s.trim()).filter(s => s.length > 0);
      }
    })))
    .reduce(
      (acc, names) => acc.concat(names),
      []
    )
  ;

  const allPackages = async () => 
    (await run(`pacman -Q`))
    .split("\n").map(s => s.trim()).filter(s => s.length > 0)
    .reduce(
      (acc, line) => {
        const [ name, version ] = line.split(" ");

        return Object.assign(acc, {
          [name]: version,
        });
      },
      {}
    )
  ;

  const depsOf = async (name) => (await run(`pactree -u ${ name }`)).split("\n").map(s => s.trim()).filter(s => s.length > 0);

  const aurInstall = (name) => run([
    `cd /tmp`,
    `curl https://aur.archlinux.org/cgit/aur.git/snapshot/${ name }.tar.gz | tar zxvf -`,
    `cd ${ name }`,
    `sudo pacman -Syu --noconfirm`,
    `sudo makepkg -sif --noconfirm`,
  ].join(" && "));

  const packageInstalled = async (name) => {
    try {
      await run(`sudo pacman -Qi ${ name }`);
      return true;
    } catch (_e) {
      return false;
    }
  };

  return async (names) => {
    for (const pkg of [ "package-query", "yaourt" ]) {
      if (!(await packageInstalled(pkg))) {
        await aurInstall(pkg);
      }
    }

    for (const name of [ "nodejs", "npm" ]) {
      if (!names.include(name)) {
        names = name.concat([name]);
      }
    }

    const allPackagesBefore = await allPackages();

    await run(`yaourt -Syua --needed --noconfirm ${ names.join(" ") }`);
    
    const namesToKeepL = Object.keys(
      (await Promise.all((await degroup(names)).map(depsOf))).reduce(
        (acc, name) => Object.assign(acc, { [name]: true }),
        {}
      )
    );

    const allNames = Object.keys(await allPackages());
    const namesToRemove = allNames.filter(name => namesToKeepL[name] !== true);
    await run(`yaourt -Rdd ${ namesToRemove.join(" ") }`);

    const allPacakgesAfter = await allPackages();

    const retval = {
      added: [],
      removed: [],
      updated: [],
    };
    for (const name of Object.keys(allPackagesAfter)) {
      if (allPackagesBefore[name] == null) {
        console.log(`Package installed: ${ name }:${ allPackagesAfter[name] }`);
        retval.added.push(name);
      }
    }
    for (const name of Object.keys(allPackagesAfter)) {
      if (allPackagesBefore[name] != null && allPackagesBefore[name] !== allPackagesAfter[name]) {
        const from = allPackagesBefore[name];
        const to   = allPackagesAfter[name];

        console.log(`Package upgraded: ${ from } -> ${ to }`);
        retval.updated.push({ from, to });
      }
    }
    for (const name of Object.keys(allPackagesBefore)) {
      if (allPackagesAfter[name] == null) {
        console.log(`Package uninstalled: ${ name }: ${ allPackagesBefore[name] }`);
        retval.removed.push(name);
      }
    }

    return retval;
  };
})();


const services = (() => {
  const writeFile = promisify(require("fs").writeFile);

  const filename = `${ __dirname }/.services.json`;

  return async (names) => {
    let existingServiceNames;
    try {
      existingServiceNames = await readFile(filename, "utf8");
    } catch (_e) {
      existingServiceNames = [];
    }

    for (const name of existingServiceNames) {
      if (!names.includes(name)) {
        await run(`systemctl disable --now ${ name }`);
      }
    }

    for (const name of names) {
      if (!existingServiceNames.includes(name)) {
        await run(`systemctl enable --now ${ name }`);
      }
    }

    await writeFile(filename, JSON.stringify(names), "utf8");
  };
})();

getPathOf("conf.js")
.then(require)
.then(async (conf) => {
  const arg = { install, packages, services, run };

  if (typeof conf === "function") {
    await conf(arg);
  } else {
    if (conf.beforePackages) {
      await conf.beforePackages(arg);
    }
    if (conf.packages) {
      await packages(conf.packages);
    }
    if (conf.afterPackages) {
      await conf.afterPackages(arg);
    }
    if (conf.services) {
      await services(conf.services);
    }
  }
})
.catch(e => {
  console.error("error occurred:", e.message);
  console.error(e.stack);
  process.exit(1);
})
;
